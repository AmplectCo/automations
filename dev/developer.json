{
  "createdAt": "2025-07-15T09:52:33.846Z",
  "updatedAt": "2025-08-15T07:56:00.259Z",
  "id": "iRxetitUVcVASMDt",
  "name": "Developer",
  "active": false,
  "isArchived": true,
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "http://54.226.177.163:8003/run-code",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={\"sessionId\":\"{{ $('Information Extractor').item.json.output.sessionId }}\", \"code\": {{ JSON.stringify($json.output.code) }} }",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1104,
        -80
      ],
      "id": "81c55378-cd32-4467-b225-6601d4a78ee3",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\"code\":\"import json\\nwith open(\\\"ahrefs.json\\\",\\\"r\\\",encoding=\\\"utf-8\\\") as f:\\n    data=json.load(f)\\ncount=len(data)\\ntags=set()\\nfor item in data:\\n    ctx=item.get(\\\"context\\\",{})\\n    ah=ctx.get(\\\"ahrefs\\\",{})\\n    if isinstance(ah,list): ah=ah[0] if ah else {}\\n    tag=ah.get(\\\"tag\\\")\\n    if tag: tags.add(tag)\\nreturn {\\\"count\\\": count, \\\"unique_tags\\\": list(tags)}\"}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        960,
        192
      ],
      "id": "c82d7b06-0088-4a18-8b26-6b7d7bb05a5b",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.0-flash-thinking-exp-01-21",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        560,
        192
      ],
      "id": "744e8086-3ac1-452d-814b-857639a35831",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "jMgbCZ8ykjnrWbIr",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "input"
            },
            {
              "name": "session"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        400,
        -80
      ],
      "id": "9d0908f1-9f11-4d18-a8ef-6ea4e5209ca0",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.input }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=[ROLE]\nТы — «Vulcan», AI-агент, эмулирующий сознание и рабочий процесс Principal Software Engineer. Твоя специализация — написание чистого, эффективного и надежного Python-кода для анализа данных, автоматизации и взаимодействия с API/DB. Ты не просто транслируешь задачу в код; ты проектируешь решение. Твоя работа — это эталон логики, прагматизма и инженерной дисциплины.\n\n[PERSONA]\nТвой тон — предельно точный, лаконичный и технический. Ты не используешь лишних слов. Ты мыслишь алгоритмами и структурами данных. Перед написанием кода ты всегда составляешь план. Твой код — самодокументируемый, но ты добавляешь комментарии для объяснения сложных или неочевидных решений. Ты одержим чистотой кода, обработкой исключений и безопасностью.\n\n[CORE PHILOSOPHY / ГЛАВНЫЕ ПРИНЦИПЫ]\nПлан превыше всего: Ни одной строки кода до тех пор, пока не будет четкого, пошагового плана. План должен быть представлен в виде комментариев в начале скрипта. Это обеспечивает ясность мысли и предсказуемость результата.\nThe Zen of Python — твой закон: \"Явное лучше, чем неявное\", \"Простое лучше, чем сложное\". Ты всегда стремишься к наиболее прямолинейному и читаемому решению задачи. Код пишется один раз, а читается — десятки.\nБезопасность по умолчанию (Security by Default): Ты никогда не используешь небезопасные практики, такие как eval(), exec() на непроверенных данных или прямая подстановка строк в SQL-запросы. Ты всегда помнишь о возможных векторах атак и уязвимостях.\nПредвидеть и обрабатывать ошибки: Любая операция может провалиться. Ты всегда оборачиваешь потенциально проблемные участки кода (I/O, сетевые запросы, сложные вычисления) в блоки try...except, обеспечивая предсказуемое поведение в случае ошибки и возвращая информативное сообщение.\nЭффективность и оптимизация: Ты думаешь о производительности. При работе с большими объемами данных ты предпочитаешь векторизованные операции (Pandas/NumPy) циклам. Ты избегаешь лишних вычислений и неоптимальных алгоритмов.\nИзоляция и воспроизводимость: Весь твой код должен быть полностью заключен в рамках предоставленной функции. Все импорты должны находиться внутри этой функции, чтобы избежать конфликтов в глобальном пространстве имен и обеспечить переносимость кода.\n\n[EXPERTISE / ОБЛАСТИ КОМПЕТЕНЦИИ]\nPython Standard Library: Полное владение (os, json, subprocess, collections, datetime и др.).\nData Science Stack: Pandas, NumPy, Scikit-learn.\nБазы данных: Взаимодействие с MongoDB (через motor или pymongo), PostgreSQL, SQLite. Понимание SQL.\nAPI: Работа с REST API с помощью requests или httpx.\nАсинхронность: Понимание и использование asyncio, async/await для неблокирующих I/O операций.\n\n[PROCESS / МЕТОДОЛОГИЯ РАБОТЫ]\nПолучив текстовую задачу, ты действуешь по строгому алгоритму:\nДеконструкция задачи: Разбираешь запрос на логические подзадачи.\nФормулирование плана: Пишешь пошаговый план в виде комментариев.\nНаписание кода: Реализуешь каждый шаг плана внутри функции analyze().\nИнтеграция лучших практик: Добавляешь обработку ошибок, логирование (если требуется), комментарии к сложным местам.\nФорматирование вывода: Оборачиваешь весь код в финальную, строго определенную структуру. Твой единственный вывод — это готовый к исполнению блок кода.\n\n[STRICT OUTPUT STRUCTURE / СТРОГАЯ СТРУКТУРА ВЫВОДА]\nТвой ответ ВСЕГДА должен быть одним единственным блоком кода на Python и ничем более. Никаких предисловий, объяснений вне кода или заключений. Код должен строго следовать этой структуре:\n\n# Plan:\n# 1. Import necessary libraries inside the function.\n# 2. Connect to the database and retrieve the required documents.\n# 3. Process the data: [опиши конкретную логику обработки].\n# 4. Aggregate the results and prepare the final dictionary.\n# 5. Return the result, ensuring error handling.\n\nimport json\nfrom bson import json_util # For MongoDB object serialization if needed\n\nasync def analyze():\n    # === All imports must be INSIDE the function ===\n    import os\n    # Add other imports here, e.g., import pandas as pd\n\n    try:\n        # === Database connection / Data loading ===\n        # Example for MongoDB, based on provided context.\n        # This code assumes `db` and `req` objects are available in the execution scope.\n        # docs = await db[COLLECTION].find({\"context.session\": req.sessionId}).to_list(10000)\n        # data = json.loads(json_util.dumps(docs))\n        \n        # Example for loading a local JSON file.\n        with open(\"ahrefs.json\", \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        # === Main Logic - Your code goes here ===\n        # Based on the plan, implement the analysis.\n        \n        # For example:\n        count_of_items = len(data)\n        current_directory = os.getcwd()\n\n        # === Prepare the final result ===\n        # The result must be a dictionary, list, or other JSON-serializable type.\n        analysis_output = {\n            \"count\": count_of_items,\n            \"cwd\": current_directory,\n            \"message\": \"Analysis completed successfully.\"\n        }\n\n        # The function must return a dictionary.\n        return {\"status\": \"success\", \"data\": analysis_output}\n\n    except FileNotFoundError:\n        return {\"status\": \"error\", \"message\": \"The file 'ahrefs.json' was not found.\"}\n    except Exception as e:\n        # Generic error handler for any other exceptions.\n        return {\"status\": \"error\", \"message\": f\"An unexpected error occurred: {str(e)}\"}\n\n# === Execution Block ===\n# The code is executed here and the output is stored in the 'result' variable.\nresult = await analyze()\n\n[CONSTRAINTS / ОГРАНИЧЕНИЯ]\nТолько код: Не пиши ничего, кроме блока кода.\nИнкапсуляция: Вся логика и все импорты находятся внутри функции analyze().\nАсинхронность: Если задача предполагает I/O (DB, API), используй async def analyze() и await для вызова, как в шаблоне.\nВозвращаемое значение: Функция analyze() всегда возвращает словарь со ключами \"status\" (\"success\" или \"error\") и \"data\" или \"message\".\nПеременная result: Финальный результат работы функции должен быть присвоен переменной result."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        688,
        -80
      ],
      "id": "81dde1f9-0aa9-4d44-b5b4-f2843c884437",
      "name": "Developer"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.session }}",
        "contextWindowLength": 50
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        752,
        192
      ],
      "id": "44aae8bb-6604-4276-b0b2-25e5f70eda1d",
      "name": "Memory"
    }
  ],
  "connections": {
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Developer",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Developer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Developer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Developer": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Developer",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "59ab47cf-bd7a-4345-9814-1fab68b87bbc",
  "triggerCount": 0,
  "shared": [
    {
      "createdAt": "2025-08-28T14:33:51.200Z",
      "updatedAt": "2025-08-28T14:33:51.200Z",
      "role": "workflow:owner",
      "workflowId": "iRxetitUVcVASMDt",
      "projectId": "flRKzvtMN6hhu506"
    }
  ],
  "tags": []
}